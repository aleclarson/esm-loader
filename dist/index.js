import l from"path";import{fileURLToPath as W,pathToFileURL as v}from"url";import{installSourceMapSupport as F,compareNodeVersion as w,resolveTsPath as R,transform as _,applySourceMap as f,transformDynamicImport as k}from"@esbuild-kit/core-utils";import{parseTsconfig as D,getTsconfig as I,createPathsMatcher as L}from"get-tsconfig";import S from"fs";const u=F(),d=process.env.ESBK_TSCONFIG_PATH?{path:process.env.ESBK_TSCONFIG_PATH,config:D(process.env.ESBK_TSCONFIG_PATH)}:I(),j=d==null?void 0:d.config,P=d&&L(d),y=/\.([cm]?ts|[tj]sx)$/,T=t=>{const s=l.extname(t);if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},g=new Map;async function M(t){if(g.has(t))return g.get(t);if(!await S.promises.access(t).then(()=>!0,()=>!1)){g.set(t,void 0);return}const o=await S.promises.readFile(t,"utf8");try{const n=JSON.parse(o);return g.set(t,n),n}catch{throw new Error(`Error parsing: ${t}`)}}async function x(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const o=W(s),n=await M(o);if(n)return n;const r=s;if(s=new URL("../package.json",s),s.pathname===r.pathname)break}}async function E(t){var s;const o=await x(t);return(s=o==null?void 0:o.type)!=null?s:"commonjs"}const A=[".js",".json",".ts",".tsx",".jsx"];async function U(t,s,o){let n;for(const r of A)try{return await h(t+r,s,o,!0)}catch(a){if(n===void 0){const{message:i}=a;a.message=a.message.replace(`${r}'`,"'"),a.stack=a.stack.replace(i,a.message),n=a}}throw n}async function O(t,s,o){const n=t.endsWith("/")?"index":"/index";try{return await U(t+n,s,o)}catch(r){const{message:a}=r;throw r.message=r.message.replace(`${n.replace("/",l.sep)}'`,"'"),r.stack=r.stack.replace(a,r.message),r}}const N="file://",b=/^\.{0,2}\//,C=w([14,13,1])>=0||w([12,20,0])>=0,h=async function(t,s,o,n){var r,a;if(!C&&t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return await O(t,s,o);const i=t.startsWith(N)||b.test(t);if(P&&!i&&!((r=s.parentURL)!=null&&r.includes("/node_modules/"))){const e=P(t);for(const p of e)try{return await h(v(p).toString(),s,o)}catch{}}if(y.test(s.parentURL)){const e=R(t);if(e)try{return await h(e,s,o,!0)}catch(p){if(p.code!=="ERR_MODULE_NOT_FOUND")throw p}}let c;try{c=await o(t,s,o)}catch(e){if(e instanceof Error&&!n){if(e.code==="ERR_UNSUPPORTED_DIR_IMPORT")return await O(t,s,o);if(e.code==="ERR_MODULE_NOT_FOUND")return await U(t,s,o)}throw e}if(c.url.endsWith(".json"))return{...c,format:"json"};let{format:m}=c;return c.url.startsWith(N)&&(m=(a=T(c.url))!=null?a:m,m||(m=await E(c.url))),{...c,format:m}},$=async function(t,s,o){process.send&&process.send({type:"dependency",path:t}),t.endsWith(".json")&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const n=await o(t,s,o);if(!n.source)return n;const r=n.source.toString();if(n.format==="json"||y.test(t)){const i=await _(r,t,{tsconfigRaw:j});return{format:"module",source:f(i,t,u)}}const a=k(r);return a&&(n.source=f(a,t,u)),n},B=async function(t,s,o){var n;return t.endsWith(".json")?{format:"module"}:t.startsWith("file:")?{format:(n=T(t))!=null?n:await E(t)}:await o(t,s,o)},H=async function(t,s,o){const{url:n}=s;if(process.send&&process.send({type:"dependency",path:n}),n.endsWith(".json")||y.test(n)){const i=await _(t.toString(),n,{tsconfigRaw:j});return{source:f(i,n,u)}}const r=await o(t,s,o),a=k(r.source.toString());return a&&(r.source=f(a,n,u)),r},J=w([16,12,0])<0,K=J?B:void 0,G=J?H:void 0;export{K as getFormat,$ as load,h as resolve,G as transformSource};
